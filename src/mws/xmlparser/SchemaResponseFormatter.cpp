/*

Copyright (C) 2010-2015 KWARC Group <kwarc.info>

This file is part of MathWebSearch.

MathWebSearch is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MathWebSearch is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MathWebSearch.  If not, see <http://www.gnu.org/licenses/>.

*/
/**
  * @author  Radu Hambasan
  * @date    30 Dec 2014
  *
  */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <libxml/encoding.h>
#include <libxml/xmlwriter.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include <string>
using std::string;
using std::to_string;
#include <vector>
using std::vector;

#include "common/utils/compiler_defs.h"
#include "mws/types/CmmlToken.hpp"
using mws::types::CmmlToken;
#include "mws/types/GenericAnswer.hpp"
#include "mws/types/SchemaAnswset.hpp"
#include "mws/types/ExprSchema.hpp"
using mws::types::ExprSchema;
#include "mws/xmlparser/SchemaResponseFormatter.hpp"

#include "build-gen/config.h"

#define SCHEMA_ANSWSET_MAIN_NAME "mws:schemata"
#define SCHEMA_ANSW_NAME "mws:schema"

using namespace mws;

struct LocalContext {
    FILE* file;
    size_t total_bytes_written;
};

static inline int fileXmlOutputWriteCallback(void* _ctxt, const char* data,
                                             int data_size) {
    LocalContext* ctxt = (LocalContext*)_ctxt;
    size_t bytes_written = fwrite(data, sizeof(char), data_size, ctxt->file);
    ctxt->total_bytes_written += bytes_written;
    return bytes_written;
}

namespace mws {
namespace parser {

SchemaResponseFormatter SchemaResponseFormatter::instance;
const SchemaResponseFormatter* RESPONSE_FORMATTER_SCHEMA =
    &SchemaResponseFormatter::instance;

static const char HTTP_ENCODING[] = "application/xml";

const char* SchemaResponseFormatter::getContentType() const {
    return HTTP_ENCODING;
}

/* TODO: write a macro for this repetitive code */
int SchemaResponseFormatter::writeData(const GenericAnswer* ans,
                                    FILE* output) const {
    SchemaAnswset& schemataSet = *((SchemaAnswset*)ans);
    xmlOutputBuffer* outPtr;
    xmlTextWriter* writerPtr;
    LocalContext ctxt;
    int ret;

    // Initializing values
    outPtr = nullptr;
    writerPtr = nullptr;
    ret = -1;
    ctxt.file = output;
    ctxt.total_bytes_written = 0;

    outPtr = xmlOutputBufferCreateIO(fileXmlOutputWriteCallback, nullptr,
                                     &ctxt, nullptr);
    if (outPtr == nullptr) {
        PRINT_WARN("Error while creating the OutputBuffer\n");
        goto finally;
    }

    writerPtr = xmlNewTextWriter(outPtr);
    if (writerPtr == nullptr) {
        PRINT_WARN("Error while creating the TextWriter\n");
        goto finally;
    }

    ret = xmlTextWriterStartDocument(writerPtr,  // xmlTextWriter
                                     nullptr,  // XML version ("1.0")
                                     nullptr,  // Encoding ("UTF-8")
                                     nullptr);  // Standalone ("yes")
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterStartDocument\n");
        goto finally;
    }

    ret = xmlTextWriterWriteComment(writerPtr,
                        BAD_CAST "Schemata generated by " MWS_BUILD);
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterWriteComment\n");
        goto finally;
    }

    ret = xmlTextWriterStartElement(writerPtr,
                                    BAD_CAST SCHEMA_ANSWSET_MAIN_NAME);
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterStartElement\n");
        goto finally;
    }

    ret = xmlTextWriterWriteAttribute(writerPtr, BAD_CAST "xmlns:mws",
                                      BAD_CAST "http://www.mathweb.org/mws/ns");
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterWriteAttribute\n");
        goto finally;
    }

    ret = xmlTextWriterWriteAttribute(
                writerPtr, BAD_CAST "size",
                BAD_CAST to_string(schemataSet.schemata.size()).c_str());
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterWriteAttribute\n");
        goto finally;
    }

    ret = xmlTextWriterWriteAttribute(writerPtr, BAD_CAST "total",
                                      BAD_CAST to_string(schemataSet.total)
                                      .c_str());
    if (ret == -1) {
        PRINT_WARN("Error at xmlTextWriterWriteAttribute\n");
        goto finally;
    }

    for (const ExprSchema& schema : schemataSet.schemata) {
        ret = xmlTextWriterStartElement(writerPtr, BAD_CAST SCHEMA_ANSW_NAME);
        if (ret == -1) {
            PRINT_WARN("Error at xmlTextWriterStartElement\n");
            break;
        }
        ret = xmlTextWriterWriteAttribute(writerPtr, BAD_CAST "coverage",
                                          BAD_CAST to_string(schema.coverage)
                                          .c_str());
        if (ret == -1) {
            PRINT_WARN("Error at xmlTextWriterWriteAttribute\n");
            goto finally;
        }

        ret = xmlTextWriterStartElement(writerPtr, BAD_CAST "math");
        if (ret == -1) {
            PRINT_WARN("Error at xmlTextWriterStartElement\n");
            break;
        }

        ret = printCmmlToken(schema.root, writerPtr);
        if (ret == -1) {
            PRINT_WARN("Error at printCmmlToken\n");
            break;
        }
        ret = xmlTextWriterEndElement(writerPtr);
        if (ret == -1) {
            PRINT_WARN("Error at xmlTextWriterEndElement\n");
            break;
        }

        ret = xmlTextWriterEndElement(writerPtr);
        if (ret == -1) {
            PRINT_WARN("Error at xmlTextWriterEndElement\n");
            break;
        }
    }

finally:
    if (ret == -1) {
        PRINT_WARN("Error while writing xml answers\n");
    } else if ((ret = xmlTextWriterEndElement(writerPtr)) == -1) {
        PRINT_WARN("Error at xmlTextWriterEndElement\n");
    } else if ((ret = xmlTextWriterEndDocument(writerPtr)) == -1) {
        PRINT_WARN("Error at xmlTextWriterEndDocument\n");
    } else if ((ret = xmlTextWriterFlush(writerPtr)) == -1) {
        PRINT_WARN("Error at xmlTextWriterFlush\n");
    } else {
        ret = 0;
    }

    if (writerPtr) {
        // This also cleans the outPtr
        xmlFreeTextWriter(writerPtr);
    } else if (outPtr) {
        xmlOutputBufferClose(outPtr);
    }

    if (ret == 0) {
        return ctxt.total_bytes_written;
    } else {
        return ret;
    }
}

int SchemaResponseFormatter::printCmmlToken(const CmmlToken *root,
                                             xmlTextWriter *wrt) const {
    int ret = 0;
    const char* tag = root->getTag().c_str();
    const char* content = root->getTextContent().c_str();
    ret = xmlTextWriterStartElement(wrt, BAD_CAST tag);
    ret = xmlTextWriterWriteString(wrt, BAD_CAST content);

    for (const CmmlToken* child : root->getChildNodes()) {
        ret = printCmmlToken(child, wrt);
        if (ret == -1) break;
    }

    ret = xmlTextWriterEndElement(wrt);

    if (ret == -1) {
        PRINT_WARN("Error while printing <%s>\n", tag);
    }
    return ret;
}

}  // namespace parser
}  // namespace mws
